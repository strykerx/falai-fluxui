/**
 * The stream API options. It requires the API input and also
 * offers configuration options.
 */
type StreamOptions<Input> = {
    /**
     * The API input payload.
     */
    readonly input?: Input;
    /**
     * The maximum time interval in milliseconds between stream chunks. Defaults to 15s.
     */
    readonly timeout?: number;
    /**
     * Whether it should auto-upload File-like types to fal's storage
     * or not.
     */
    readonly autoUpload?: boolean;
    /**
     * The HTTP method, defaults to `post`;
     */
    readonly method?: 'get' | 'post' | 'put' | 'delete' | string;
};
type FalStreamEventType = 'message' | 'error' | 'done';
type EventHandler = (event: any) => void;
/**
 * The class representing a streaming response. With t
 */
export declare class FalStream<Input, Output> {
    url: string;
    options: StreamOptions<Input>;
    private listeners;
    private buffer;
    private currentData;
    private lastEventTimestamp;
    private streamClosed;
    private donePromise;
    constructor(url: string, options: StreamOptions<Input>);
    private start;
    private handleResponse;
    private handleError;
    on: (type: FalStreamEventType, listener: EventHandler) => void;
    private emit;
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<Output>, void, unknown>;
    /**
     * Gets a reference to the `Promise` that indicates whether the streaming
     * is done or not. Developers should always call this in their apps to ensure
     * the request is over.
     *
     * An alternative to this, is to use `on('done')` in case your application
     * architecture works best with event listeners.
     *
     * @returns the promise that resolves when the request is done.
     */
    done: () => Promise<Output>;
}
/**
 * Calls a fal app that supports streaming and provides a streaming-capable
 * object as a result, that can be used to get partial results through either
 * `AsyncIterator` or through an event listener.
 *
 * @param appId the app id, e.g. `fal-ai/llavav15-13b`.
 * @param options the request options, including the input payload.
 * @returns the `FalStream` instance.
 */
export declare function stream<Input = Record<string, any>, Output = any>(appId: string, options: StreamOptions<Input>): Promise<FalStream<Input, Output>>;
export {};
