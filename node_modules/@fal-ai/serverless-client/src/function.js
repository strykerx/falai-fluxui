"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queue = exports.subscribe = exports.run = exports.send = exports.buildUrl = void 0;
const auth_1 = require("./auth");
const request_1 = require("./request");
const storage_1 = require("./storage");
const streaming_1 = require("./streaming");
const utils_1 = require("./utils");
/**
 * Builds the final url to run the function based on its `id` or alias and
 * a the options from `RunOptions<Input>`.
 *
 * @private
 * @param id the function id or alias
 * @param options the run options
 * @returns the final url to run the function
 */
function buildUrl(id, options = {}) {
    var _a, _b;
    const method = ((_a = options.method) !== null && _a !== void 0 ? _a : 'post').toLowerCase();
    const path = ((_b = options.path) !== null && _b !== void 0 ? _b : '').replace(/^\//, '').replace(/\/{2,}/, '/');
    const input = options.input;
    const params = Object.assign(Object.assign({}, (options.query || {})), (method === 'get' ? input : {}));
    const queryParams = Object.keys(params).length > 0
        ? `?${new URLSearchParams(params).toString()}`
        : '';
    const parts = id.split('/');
    // if a fal url is passed, just use it
    if ((0, utils_1.isValidUrl)(id)) {
        const url = id.endsWith('/') ? id : `${id}/`;
        return `${url}${path}${queryParams}`;
    }
    // TODO remove this after some time, fal.run should be preferred
    if (parts.length === 2 && (0, utils_1.isUUIDv4)(parts[1])) {
        const host = 'gateway.shark.fal.ai';
        return `https://${host}/trigger/${id}/${path}${queryParams}`;
    }
    const appId = (0, utils_1.ensureAppIdFormat)(id);
    const subdomain = options.subdomain ? `${options.subdomain}.` : '';
    const url = `https://${subdomain}fal.run/${appId}/${path}`;
    return `${url.replace(/\/$/, '')}${queryParams}`;
}
exports.buildUrl = buildUrl;
function send(id, options = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const input = options.input && options.autoUpload !== false
            ? yield storage_1.storageImpl.transformInput(options.input)
            : options.input;
        return (0, request_1.dispatchRequest)((_a = options.method) !== null && _a !== void 0 ? _a : 'post', buildUrl(id, options), input);
    });
}
exports.send = send;
/**
 * Runs a fal serverless function identified by its `id`.
 *
 * @param id the registered function revision id or alias.
 * @returns the remote function output
 */
function run(id, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return send(id, options);
    });
}
exports.run = run;
const DEFAULT_POLL_INTERVAL = 500;
/**
 * Subscribes to updates for a specific request in the queue.
 *
 * @param id - The ID or URL of the function web endpoint.
 * @param options - Options to configure how the request is run and how updates are received.
 * @returns A promise that resolves to the result of the request once it's completed.
 */
function subscribe(id, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { request_id: requestId } = yield exports.queue.submit(id, options);
        if (options.onEnqueue) {
            options.onEnqueue(requestId);
        }
        if (options.mode === 'streaming') {
            const status = yield exports.queue.streamStatus(id, {
                requestId,
                logs: options.logs,
            });
            const logs = [];
            status.on('message', (data) => {
                if (options.onQueueUpdate) {
                    // accumulate logs to match previous polling behavior
                    if ('logs' in data &&
                        Array.isArray(data.logs) &&
                        data.logs.length > 0) {
                        logs.push(...data.logs);
                    }
                    options.onQueueUpdate('logs' in data ? Object.assign(Object.assign({}, data), { logs }) : data);
                }
            });
            yield status.done();
            return exports.queue.result(id, { requestId });
        }
        // default to polling until status streaming is stable and faster
        return new Promise((resolve, reject) => {
            var _a;
            let timeoutId;
            const pollInterval = (_a = options.pollInterval) !== null && _a !== void 0 ? _a : DEFAULT_POLL_INTERVAL;
            const poll = () => __awaiter(this, void 0, void 0, function* () {
                var _b;
                try {
                    const requestStatus = yield exports.queue.status(id, {
                        requestId,
                        logs: (_b = options.logs) !== null && _b !== void 0 ? _b : false,
                    });
                    if (options.onQueueUpdate) {
                        options.onQueueUpdate(requestStatus);
                    }
                    if (requestStatus.status === 'COMPLETED') {
                        clearTimeout(timeoutId);
                        try {
                            const result = yield exports.queue.result(id, { requestId });
                            resolve(result);
                        }
                        catch (error) {
                            reject(error);
                        }
                        return;
                    }
                    timeoutId = setTimeout(poll, pollInterval);
                }
                catch (error) {
                    clearTimeout(timeoutId);
                    reject(error);
                }
            });
            poll().catch(reject);
        });
    });
}
exports.subscribe = subscribe;
/**
 * The fal run queue module. It allows to submit a function to the queue and get its result
 * on a separate call. This is useful for long running functions that can be executed
 * asynchronously and not .
 */
exports.queue = {
    submit(endpointId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { webhookUrl, path = '' } = options, runOptions = __rest(options, ["webhookUrl", "path"]);
            return send(endpointId, Object.assign(Object.assign({}, runOptions), { subdomain: 'queue', method: 'post', path: path, query: webhookUrl ? { fal_webhook: webhookUrl } : undefined }));
        });
    },
    status(endpointId, { requestId, logs = false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const appId = (0, utils_1.parseAppId)(endpointId);
            const prefix = appId.namespace ? `${appId.namespace}/` : '';
            return send(`${prefix}${appId.owner}/${appId.alias}`, {
                subdomain: 'queue',
                method: 'get',
                path: `/requests/${requestId}/status`,
                input: {
                    logs: logs ? '1' : '0',
                },
            });
        });
    },
    streamStatus(endpointId, { requestId, logs = false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const appId = (0, utils_1.parseAppId)(endpointId);
            const prefix = appId.namespace ? `${appId.namespace}/` : '';
            const token = yield (0, auth_1.getTemporaryAuthToken)(endpointId);
            const url = buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {
                subdomain: 'queue',
                path: `/requests/${requestId}/status/stream`,
            });
            const queryParams = new URLSearchParams({
                fal_jwt_token: token,
                logs: logs ? '1' : '0',
            });
            return new streaming_1.FalStream(`${url}?${queryParams}`, {
                input: {},
                method: 'get',
            });
        });
    },
    result(endpointId, { requestId }) {
        return __awaiter(this, void 0, void 0, function* () {
            const appId = (0, utils_1.parseAppId)(endpointId);
            const prefix = appId.namespace ? `${appId.namespace}/` : '';
            return send(`${prefix}${appId.owner}/${appId.alias}`, {
                subdomain: 'queue',
                method: 'get',
                path: `/requests/${requestId}`,
            });
        });
    },
    subscribe,
};
//# sourceMappingURL=function.js.map