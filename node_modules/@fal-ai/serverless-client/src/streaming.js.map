{"version":3,"file":"streaming.js","sourceRoot":"","sources":["../../../../libs/client/src/streaming.ts"],"names":[],"mappings":"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","sourcesContent":["import { createParser } from 'eventsource-parser';\nimport { getTemporaryAuthToken } from './auth';\nimport { buildUrl } from './function';\nimport { ApiError, defaultResponseHandler } from './response';\nimport { storageImpl } from './storage';\n\n/**\n * The stream API options. It requires the API input and also\n * offers configuration options.\n */\ntype StreamOptions<Input> = {\n  /**\n   * The API input payload.\n   */\n  readonly input?: Input;\n\n  /**\n   * The maximum time interval in milliseconds between stream chunks. Defaults to 15s.\n   */\n  readonly timeout?: number;\n\n  /**\n   * Whether it should auto-upload File-like types to fal's storage\n   * or not.\n   */\n  readonly autoUpload?: boolean;\n\n  /**\n   * The HTTP method, defaults to `post`;\n   */\n  readonly method?: 'get' | 'post' | 'put' | 'delete' | string;\n};\n\nconst EVENT_STREAM_TIMEOUT = 15 * 1000;\n\ntype FalStreamEventType = 'message' | 'error' | 'done';\n\ntype EventHandler = (event: any) => void;\n\n/**\n * The class representing a streaming response. With t\n */\nexport class FalStream<Input, Output> {\n  // properties\n  url: string;\n  options: StreamOptions<Input>;\n\n  // support for event listeners\n  private listeners: Map<FalStreamEventType, EventHandler[]> = new Map();\n  private buffer: Output[] = [];\n\n  // local state\n  private currentData: Output | undefined = undefined;\n  private lastEventTimestamp = 0;\n  private streamClosed = false;\n  private donePromise: Promise<Output>;\n\n  constructor(url: string, options: StreamOptions<Input>) {\n    this.url = url;\n    this.options = options;\n    this.donePromise = new Promise<Output>((resolve, reject) => {\n      if (this.streamClosed) {\n        reject(\n          new ApiError({\n            message: 'Streaming connection is already closed.',\n            status: 400,\n            body: undefined,\n          })\n        );\n      }\n      this.on('done', (data) => {\n        this.streamClosed = true;\n        resolve(data);\n      });\n      this.on('error', (error) => {\n        this.streamClosed = true;\n        reject(error);\n      });\n    });\n    this.start().catch(this.handleError);\n  }\n\n  private start = async () => {\n    const { url, options } = this;\n    const { input, method = 'post' } = options;\n    try {\n      const response = await fetch(url, {\n        method: method.toUpperCase(),\n        headers: {\n          accept: 'text/event-stream',\n          'content-type': 'application/json',\n        },\n        body: input && method !== 'get' ? JSON.stringify(input) : undefined,\n      });\n      this.handleResponse(response);\n    } catch (error) {\n      this.handleError(error);\n    }\n  };\n\n  private handleResponse = async (response: Response) => {\n    if (!response.ok) {\n      try {\n        // we know the response failed, call the response handler\n        // so the exception gets converted to ApiError correctly\n        await defaultResponseHandler(response);\n      } catch (error) {\n        this.emit('error', error);\n      }\n      return;\n    }\n\n    const body = response.body;\n    if (!body) {\n      this.emit(\n        'error',\n        new ApiError({\n          message: 'Response body is empty.',\n          status: 400,\n          body: undefined,\n        })\n      );\n      return;\n    }\n    const decoder = new TextDecoder('utf-8');\n    const reader = response.body.getReader();\n\n    const parser = createParser((event) => {\n      if (event.type === 'event') {\n        const data = event.data;\n\n        try {\n          const parsedData = JSON.parse(data);\n          this.buffer.push(parsedData);\n          this.currentData = parsedData;\n          this.emit('message', parsedData);\n        } catch (e) {\n          this.emit('error', e);\n        }\n      }\n    });\n\n    const timeout = this.options.timeout ?? EVENT_STREAM_TIMEOUT;\n\n    const readPartialResponse = async () => {\n      const { value, done } = await reader.read();\n      this.lastEventTimestamp = Date.now();\n\n      parser.feed(decoder.decode(value));\n\n      if (Date.now() - this.lastEventTimestamp > timeout) {\n        this.emit(\n          'error',\n          new ApiError({\n            message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,\n            status: 408,\n          })\n        );\n      }\n\n      if (!done) {\n        readPartialResponse().catch(this.handleError);\n      } else {\n        this.emit('done', this.currentData);\n      }\n    };\n\n    readPartialResponse().catch(this.handleError);\n    return;\n  };\n\n  private handleError = (error: any) => {\n    const apiError =\n      error instanceof ApiError\n        ? error\n        : new ApiError({\n            message: error.message ?? 'An unknown error occurred',\n            status: 500,\n          });\n    this.emit('error', apiError);\n    return;\n  };\n\n  public on = (type: FalStreamEventType, listener: EventHandler) => {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, []);\n    }\n    this.listeners.get(type)?.push(listener);\n  };\n\n  private emit = (type: FalStreamEventType, event: any) => {\n    const listeners = this.listeners.get(type) || [];\n    for (const listener of listeners) {\n      listener(event);\n    }\n  };\n\n  async *[Symbol.asyncIterator]() {\n    let running = true;\n    const stopAsyncIterator = () => (running = false);\n    this.on('error', stopAsyncIterator);\n    this.on('done', stopAsyncIterator);\n    while (running) {\n      const data = this.buffer.shift();\n      if (data) {\n        yield data;\n      }\n\n      // the short timeout ensures the while loop doesn't block other\n      // frames getting executed concurrently\n      await new Promise((resolve) => setTimeout(resolve, 16));\n    }\n  }\n\n  /**\n   * Gets a reference to the `Promise` that indicates whether the streaming\n   * is done or not. Developers should always call this in their apps to ensure\n   * the request is over.\n   *\n   * An alternative to this, is to use `on('done')` in case your application\n   * architecture works best with event listeners.\n   *\n   * @returns the promise that resolves when the request is done.\n   */\n  public done = async () => this.donePromise;\n}\n\n/**\n * Calls a fal app that supports streaming and provides a streaming-capable\n * object as a result, that can be used to get partial results through either\n * `AsyncIterator` or through an event listener.\n *\n * @param appId the app id, e.g. `fal-ai/llavav15-13b`.\n * @param options the request options, including the input payload.\n * @returns the `FalStream` instance.\n */\nexport async function stream<Input = Record<string, any>, Output = any>(\n  appId: string,\n  options: StreamOptions<Input>\n): Promise<FalStream<Input, Output>> {\n  const token = await getTemporaryAuthToken(appId);\n  const url = buildUrl(appId, { path: '/stream' });\n\n  const input =\n    options.input && options.autoUpload !== false\n      ? await storageImpl.transformInput(options.input)\n      : options.input;\n\n  const queryParams = new URLSearchParams({\n    fal_jwt_token: token,\n  });\n\n  return new FalStream<Input, Output>(`${url}?${queryParams}`, {\n    ...options,\n    input: input as Input,\n  });\n}\n"]}