"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stream = exports.FalStream = void 0;
const eventsource_parser_1 = require("eventsource-parser");
const auth_1 = require("./auth");
const function_1 = require("./function");
const response_1 = require("./response");
const storage_1 = require("./storage");
const EVENT_STREAM_TIMEOUT = 15 * 1000;
/**
 * The class representing a streaming response. With t
 */
class FalStream {
    constructor(url, options) {
        // support for event listeners
        this.listeners = new Map();
        this.buffer = [];
        // local state
        this.currentData = undefined;
        this.lastEventTimestamp = 0;
        this.streamClosed = false;
        this.start = () => __awaiter(this, void 0, void 0, function* () {
            const { url, options } = this;
            const { input, method = 'post' } = options;
            try {
                const response = yield fetch(url, {
                    method: method.toUpperCase(),
                    headers: {
                        accept: 'text/event-stream',
                        'content-type': 'application/json',
                    },
                    body: input && method !== 'get' ? JSON.stringify(input) : undefined,
                });
                this.handleResponse(response);
            }
            catch (error) {
                this.handleError(error);
            }
        });
        this.handleResponse = (response) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!response.ok) {
                try {
                    // we know the response failed, call the response handler
                    // so the exception gets converted to ApiError correctly
                    yield (0, response_1.defaultResponseHandler)(response);
                }
                catch (error) {
                    this.emit('error', error);
                }
                return;
            }
            const body = response.body;
            if (!body) {
                this.emit('error', new response_1.ApiError({
                    message: 'Response body is empty.',
                    status: 400,
                    body: undefined,
                }));
                return;
            }
            const decoder = new TextDecoder('utf-8');
            const reader = response.body.getReader();
            const parser = (0, eventsource_parser_1.createParser)((event) => {
                if (event.type === 'event') {
                    const data = event.data;
                    try {
                        const parsedData = JSON.parse(data);
                        this.buffer.push(parsedData);
                        this.currentData = parsedData;
                        this.emit('message', parsedData);
                    }
                    catch (e) {
                        this.emit('error', e);
                    }
                }
            });
            const timeout = (_a = this.options.timeout) !== null && _a !== void 0 ? _a : EVENT_STREAM_TIMEOUT;
            const readPartialResponse = () => __awaiter(this, void 0, void 0, function* () {
                const { value, done } = yield reader.read();
                this.lastEventTimestamp = Date.now();
                parser.feed(decoder.decode(value));
                if (Date.now() - this.lastEventTimestamp > timeout) {
                    this.emit('error', new response_1.ApiError({
                        message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,
                        status: 408,
                    }));
                }
                if (!done) {
                    readPartialResponse().catch(this.handleError);
                }
                else {
                    this.emit('done', this.currentData);
                }
            });
            readPartialResponse().catch(this.handleError);
            return;
        });
        this.handleError = (error) => {
            var _a;
            const apiError = error instanceof response_1.ApiError
                ? error
                : new response_1.ApiError({
                    message: (_a = error.message) !== null && _a !== void 0 ? _a : 'An unknown error occurred',
                    status: 500,
                });
            this.emit('error', apiError);
            return;
        };
        this.on = (type, listener) => {
            var _a;
            if (!this.listeners.has(type)) {
                this.listeners.set(type, []);
            }
            (_a = this.listeners.get(type)) === null || _a === void 0 ? void 0 : _a.push(listener);
        };
        this.emit = (type, event) => {
            const listeners = this.listeners.get(type) || [];
            for (const listener of listeners) {
                listener(event);
            }
        };
        /**
         * Gets a reference to the `Promise` that indicates whether the streaming
         * is done or not. Developers should always call this in their apps to ensure
         * the request is over.
         *
         * An alternative to this, is to use `on('done')` in case your application
         * architecture works best with event listeners.
         *
         * @returns the promise that resolves when the request is done.
         */
        this.done = () => __awaiter(this, void 0, void 0, function* () { return this.donePromise; });
        this.url = url;
        this.options = options;
        this.donePromise = new Promise((resolve, reject) => {
            if (this.streamClosed) {
                reject(new response_1.ApiError({
                    message: 'Streaming connection is already closed.',
                    status: 400,
                    body: undefined,
                }));
            }
            this.on('done', (data) => {
                this.streamClosed = true;
                resolve(data);
            });
            this.on('error', (error) => {
                this.streamClosed = true;
                reject(error);
            });
        });
        this.start().catch(this.handleError);
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            let running = true;
            const stopAsyncIterator = () => (running = false);
            this.on('error', stopAsyncIterator);
            this.on('done', stopAsyncIterator);
            while (running) {
                const data = this.buffer.shift();
                if (data) {
                    yield yield __await(data);
                }
                // the short timeout ensures the while loop doesn't block other
                // frames getting executed concurrently
                yield __await(new Promise((resolve) => setTimeout(resolve, 16)));
            }
        });
    }
}
exports.FalStream = FalStream;
/**
 * Calls a fal app that supports streaming and provides a streaming-capable
 * object as a result, that can be used to get partial results through either
 * `AsyncIterator` or through an event listener.
 *
 * @param appId the app id, e.g. `fal-ai/llavav15-13b`.
 * @param options the request options, including the input payload.
 * @returns the `FalStream` instance.
 */
function stream(appId, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const token = yield (0, auth_1.getTemporaryAuthToken)(appId);
        const url = (0, function_1.buildUrl)(appId, { path: '/stream' });
        const input = options.input && options.autoUpload !== false
            ? yield storage_1.storageImpl.transformInput(options.input)
            : options.input;
        const queryParams = new URLSearchParams({
            fal_jwt_token: token,
        });
        return new FalStream(`${url}?${queryParams}`, Object.assign(Object.assign({}, options), { input: input }));
    });
}
exports.stream = stream;
//# sourceMappingURL=streaming.js.map